# goit-algo-hw-04
--------


### Результати тесту  

| Algorithm      |       Small |      Medium |       Large |
|:---------------|------------:|------------:|------------:|
| Insertion Sort | 0.000267042 | 0.0140921   |  1.17175    |
| Merge Sort     | 0.00138992  | 0.0166872   |  0.27504    |
| Quicksort      | 0.00106017  | 0.0114046   |  0.0959167  |
| Bubble Sort    | 0.002922    | 0.382407    | 46.2415     |
| Timsorted      | 1.65831e-05 | 8.8833e-05  |  0.00122762 |
| Timsort        | 2.44579e-05 | 9.13341e-05 |  0.00112833 |


### Час обробки   
Серед найбільш швидкодіючих методів сортування виділяються Timsort та Timsorted, які базуються на удосконалених варіантах алгоритму сортування злиттям і демонструють мінімальний час обробки для будь-яких обсягів даних. Зокрема, при середніх розмірах даних Timsort працює ще швидше, ніж Timsorted, що, ймовірно, зумовлено використанням більш ефективної реалізації.   

### Продуктивність зі зростанням даних   
Зауважується, що час обробки алгоритмів Bubble Sort та Insertion Sort збільшується значно швидше в порівнянні з Merge Sort та Quicksort при збільшенні обсягів даних. Це вказує на меншу ефективність Bubble Sort та Insertion Sort при обробці великих масивів даних порівняно з Merge Sort і Quicksort.

### Показники на великих даних   
При аналізі великих даних (10 000 записів) найгірші показники часу обробки має Bubble Sort, що робить його недоцільним для застосування на великих масивах через його квадратичну складність. У той же час, Merge Sort та Quicksort показали кращі результати на великих обсягах даних, що робить їх більш застосовними для таких завдань.   

### Основний висновок   
При необхідності сортування великих масивів даних слід вибирати алгоритми з часом виконання лінійно-логарифмічним (O(n log n)), як-от Merge Sort та Quicksort. Для менших масивів можна застосовувати простіші методи, такі як Insertion Sort або Bubble Sort, але варто бути уважним до їх обмеженої продуктивності на великих обсягах даних. 
При цьому варто зауважити, що Timsort та Timsorted є абсолютними переможцями по швидкості виконання для великих наборів данних, тому розробникам на мові python немає дожного сенсу писати власні алгоритми сортування.